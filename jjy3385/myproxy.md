> malloc 했던 것처럼 설계과정을 구현조건과 상태모델, 연산으로 나눠서 정의해보자
> 근데, proxylab.pdf 영어로 된 명세가 충분히 상세하다

# 순차 프록시

## 구현조건
> 구현조건 자체가 상태모델인듯, 받은 요청을 어떤 모양으로 만들어서 전달해야될지 여기서 정해짐

#### 기본사항
> HTTP 요청은 이렇게 생김<br>
> `GET http://localhost:8000 HTTP/1.1`

- 엔드서버로 HTTP/1.0 GET 요청 전달
    - `메소드` `URI` `버전` 
    - URI 는 Host 부분 제외해서 보냄
    - GET 요청 밑에 항상 빈 줄 추가(`\r\n`)
- 헤더
    - Host 헤더 항상 포함
    - User-Agent 헤더는 항상 고정값 = `User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n`
    - Connection 헤더
        - Connection: close
        - Proxy-Connection: close

- 포트
    - HTTP 요청 포트는 옵션<br>
    따라서 HTTP 요청 URL 에 포트가 있으면 그거 쓰고 없으면 80포트 사용

## 연산

### 1. 리스닝
    - 프록시 서버의 리스닝 포트는 4500
    - 요청에 대한 연결 처리(`connfd`)
    - HTTP 요청을 프록시 서버에 저장

### 2.파싱
    - HTTP 요청을 재구성
    - `메소드` `URI` `버전` 형태(버전은 항상 HTTP/1.0)
    - 빈 줄 추가(`\r\n`) 까먹으면 안됨
    - 헤더(Host,User-Agent,Connetion) 추가
    - 그 외 헤더들은 그냥 그대로 전달

- URI 구성 시 `/` 를 따로 분기처리가 필요했었음

### 3.엔드서버로 HTTP 요청 보내기
    - 구성한 HTTP 요청을 전달
    - 엔드서버와 연결(clientfd)

### 4.엔드서버의 HTTP 응답을 받아서 클라이언트로 최종 전달
    - 이거 해야되서 connfd 끊으면 안될듯
    - 응답 헤더를 파싱
    - 응답이 매우 길거나 바이너리인 경우도 고려


### 트러블

1. RIO 함수
    - RIO 함수 이해를 못함.특히, 반환값이 있는 RIO 함수들 이해를 못함
    - 그래서 엔드서버 응답을 릴레이 해줄 때 버퍼보다 큰 경우에 끊어먹음

2. C 문자열처리 함수들
    - 종류도 다양하고 사용법도 좀 특이해서 애먹음
    - 예를 들면, strtok_r 같은애들은 반환값도 없는데 포인터 위치는 진행되어 있음
    - 그래서 이거 활용해서 HTTP 요청 파싱할 때 자꾸 오류냄
    - 대표함수 : strchr(), strstr()




